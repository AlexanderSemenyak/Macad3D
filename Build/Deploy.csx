#load "_Common.csx"
#load "_BuildTools.csx"
#load "_ThirdParty.csx"
#load "_SSIndex.csx"
#load "_Version.csx"
#load "_Packages.csx"

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Runtime.InteropServices;
using System.Linq;
using System.Reflection;

if (Args.Count() < 1)
{
    Printer.Line("Usage: deploy <setup, symstore>");
    return -1;
}

var config = Args[0].ToLower();

if (config == "setup")
{
    if(!_EnhanceFileList())
        return -1;
    if (!_BuildSetup())
        return -1;
}
else if (config == "symstore")
{
    if (Args.Count() < 2)
    {
        Printer.Line("Usage: deploy symstore <path_to_store>");
        return -1;
    }

    if(!_EnhanceFileList())
        return -1;
    if (!_SourceIndexPdbs())
        return -1;
    if (!_StoreSymbols(Args[1]))
        return -1;
}
else
{
    Printer.Error("Invalid command.");
    return -1;
}

Printer.Success("Deploy succeeded.");
return 0;

/***************************************************************/

const string DotNetVersion = "4.8";
const string DotNetRelease = "528040";
const string DotNetInstaller = "ndp48-web.exe";

/***************************************************************/

static Dictionary<string, List<string>> FileSets = new Dictionary<string, List<string>> {
    // OCCT and it's dependencies will be added automatically
    { "app", new List<string> {
        @"Bin\Release\Macad.exe",
        @"Bin\Doc\Macad.UserGuide.chm",
        @"Bin\Release\AvalonDock.Themes.VS2013.dll",
    }},
    { "shellext", new List<string> {
        @"Bin\Release\Macad.ShellExtension.dll",
    }},
    { "samples", new List<string> {
        @"Data\Samples\*.*",
    }},
};

/***************************************************************/

static Dictionary<string, string> TargetDirectories = new Dictionary<string, string> {
    { "app",        @"{app}" },
    { "shellext",   @"{app}" },
    { "samples",    @"{app}\Samples" },
};

/***************************************************************/

VisualStudio _VS;

/***************************************************************/

bool _EnsureVS()
{
    if (_VS == null)
    {
        _VS = new VisualStudio();
    }
    return _VS.IsReady;
}

/***************************************************************/

bool _EnhanceFileList()
{
    FileSets["app"].AddRange(Occt.GetDeployFiles().Where(s => Path.GetExtension(s).ToLower() != ".pdb"));
    if(!_FindFileDependencies())
        return false;

    return true;
}

/***************************************************************/

bool _BuildSetup()
{
    _EnsureVS();

    // Ensure redist packages
    var dotNetInstallerPath = Packages.FindPackageFile($"DotNetRedist.{DotNetVersion}", DotNetInstaller);
	if(string.IsNullOrEmpty(dotNetInstallerPath))
		return false;

    // Ensure installer
    var setupCompilerPath = Packages.FindPackageFile($"Tools.InnoSetup.*", "tools\\iscc.exe");
	if(string.IsNullOrEmpty(setupCompilerPath))
		return false;

    // Go
    var rootPath = Common.GetRootFolder();
    var defFile = File.CreateText(Path.Combine(Common.GetRootFolder(), @"Build\Setup\_GeneratedDefinitions.iss"));
    defFile.WriteLine($"; Generated by deploy script on {DateTime.Now.ToString()}\n");

    // Write version
    int major, minor, flags, revision;
    if(!Version.ReadCurrentVersion(out major, out minor, out revision, out flags))
    {
        Printer.Error("Cannot read version information.");
        return false;
    }
    defFile.WriteLine($"#define MyAppVersion '{major}.{minor}.{flags}'");
    defFile.WriteLine($"#define MyAppVersionStr '{major}.{minor}" + (flags==0 ? "" : $"_{Version.GetFlagsString(flags)}'"));
    defFile.WriteLine($"#define MyAppRevision '{major}.{minor}.{revision}.{flags}'");
    defFile.WriteLine("");
    
    // Write VCRedist definitions
    defFile.WriteLine($"#define VcRedistDisplayedVersion 2019");
    var redistDir = _VS.GetPathToVcRedist();
    defFile.WriteLine($"#define VcRedistDir '{redistDir}'");
    var redistVersion = _VS.GetVersionOfVcRedist();
    defFile.WriteLine($"#define VcRedistMajor {redistVersion[0]}");
    defFile.WriteLine($"#define VcRedistMinor {redistVersion[1]}");
    defFile.WriteLine($"#define VcRedistBuild {redistVersion[2]}");
    defFile.WriteLine("");

    // Write DotNet definitions
    defFile.WriteLine($"#define DotNetDisplayedVersion '{DotNetVersion}'");
    defFile.WriteLine($"#define DotNetInstaller '{dotNetInstallerPath}'");
    defFile.WriteLine($"#define DotNetMajor {DotNetVersion[0]}");
    defFile.WriteLine($"#define DotNetRelease {DotNetRelease}");
    defFile.WriteLine("");

    // Write Files
    defFile.WriteLine("[Files]");
    foreach (var files in FileSets)
    {
        defFile.WriteLine($"; Files of set {files.Key}");
        var targetDir = TargetDirectories[files.Key];
        var fileFlags = "ignoreversion";
        if(files.Key == "shellext")
        {
            fileFlags += " 64bit restartreplace regserver uninsrestartdelete";
        }

        foreach (var file in files.Value)
        {
            if(file.IndexOf('*') >= 0)
            {
                // Wildcard
                foreach(var wcfile in Directory.EnumerateFiles(Path.GetDirectoryName($"{rootPath}{file}"), "*.*"))
                {
                    defFile.WriteLine($"Source: \"{wcfile}\"; DestDir: \"{targetDir}\"; Flags: {fileFlags}");
                }
            } 
            else 
            {
                // Explicit file
                defFile.WriteLine($"Source: \"{rootPath}{file}\"; DestDir: \"{targetDir}\"; Flags: {fileFlags}");
            }
        }
    }
    defFile.WriteLine("");

    defFile.Close();

    // Call InnoSetup
    Printer.Success($"\nCalling InnoSetup compiler...");

    var commandLine = $"/Qp \"{rootPath}\\Build\\Setup\\MacadSetup.iss\"";

    if (Common.Run(setupCompilerPath, commandLine) != 0)
    {
        Printer.Error("Compiling installer failed.");
        return false;
    }
    return true;
}

/***************************************************************/

bool _SourceIndexPdbs()
{
    SSIndex ssindex = new SSIndex();

    if (!ssindex.Init(Common.GetRootFolder()))
    {
        Printer.Error("Source indexing failed.");
        return false;
    }

    Printer.Line("Staring source indexing of pdb files...");

    foreach (var files in FileSets)
    {
        foreach (var file in files.Value)
        {
            var pdbPath = Path.Combine(Common.GetRootFolder(), Path.ChangeExtension(file, ".pdb"));

            if (File.Exists(pdbPath))
            {
                if (!ssindex.ProcessPdb(pdbPath))
                {
                    Printer.Error("Source indexing failed.");
                    return false;
                }
            }
        }
    }

    Printer.Success("Source indexing finished.");

    return true;
}

/***************************************************************/

bool _StoreSymbols(string pathToSymstore)
{
    Printer.Line($"\nStoring symbol files to {pathToSymstore}...");

    var exePath = Path.Combine(VisualStudio.GetPathToWindowsSDK(), @"..\..\Debuggers\x64\symstore.exe");

    if (!File.Exists(exePath))
    {
        Printer.Error("SymStore not found in path " + exePath);
        Printer.Error("Make sure that the Windows Debugging Tools are installed.");
        return false;
    }
    
    // Get version
    int major, minor, build, revision;
    if(!Version.ReadCurrentVersion(out major, out minor, out build, out revision))
    {
        Printer.Error("Cannot read version information.");
        return false;
    }
    
    // Write file list
    using (var fileListStream = new StreamWriter("FilesToSymStore.txt", false, Encoding.ASCII))
    {
        foreach (var files in FileSets)
        {
            foreach (var file in files.Value)
            {
                var path = Path.Combine(Common.GetRootFolder(), file);
                var ext = Path.GetExtension(path).ToLower();

                if (ext == ".exe" || ext == ".dll")
                {
                    fileListStream.WriteLine(path);

                    var pdbPath = Path.ChangeExtension(path, ".pdb");

                    if (File.Exists(pdbPath))
                    {
                        fileListStream.WriteLine(pdbPath);
                    }
                }
            }
        }
    }

    var commandLine = $"add /compress /f @FilesToSymStore.txt /s \"{pathToSymstore}\" /t Macad /v {major}.{minor}.{build}.{revision}";

    if (Common.Run(exePath, commandLine) != 0)
    {
        Printer.Error("Storing symbols failed.");
        return false;
    }

    File.Delete("FilesToSymStore.txt");

    Printer.Success("\nSymbols stored successfully.");
    return true;
}

/***************************************************************/

bool _FindFileDependencies()
{
    foreach (var files in FileSets)
    {
        for(int i=0; i<files.Value.Count; i++)
        {
            var file = files.Value[i];
            var ext = Path.GetExtension(file).ToLower();
            if(ext != ".dll" && ext != ".exe")
                continue;
            var relativeDir = Path.GetDirectoryName(file);

            // Check for .config
            if(File.Exists(Path.Combine(Common.GetRootFolder(), file + ".config")))
            {
                files.Value.Add(file + ".config");
            }

            // Check for references assemblies
            try
            {
                var asm = Assembly.ReflectionOnlyLoadFrom(Path.Combine(Common.GetRootFolder(), file));
                foreach(var refName in asm.GetReferencedAssemblies())
                {
                    var asmRelPath = Path.Combine(relativeDir, refName.Name + ".dll");
                    if(files.Value.Any(fn => String.Compare(fn, asmRelPath)==0))
                        continue;
                    if(!File.Exists(Path.Combine(Common.GetRootFolder(), asmRelPath)))
                        continue;

                    files.Value.Add(asmRelPath);
                }
            }
            catch (System.Exception)
            {
                continue;
            }
        }
    }
    return true;
}